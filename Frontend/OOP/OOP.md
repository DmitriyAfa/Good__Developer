## ООП парадигма

# Объекты

ИНКАПСУЛЯЦИЯ
НАСЛЕДОВАНИЕ
DEP.INJECTION

# Классы

ПОЛИМОРФИЗМ
КОМПОЗИЦИЯ
ИНТЕРФЕЙСЫ

# Процедурный подход

Программа написанная в процедурном стиле ожидает на вход какие-то данны --->
выполняет ряд каких-то процедур (функций) --->
и после этого возвращает какой то результат вычисления

      Данные                  |---  функция 1     |  результат
     ----------> программа ---|---  функция 1     |------------->
                              |---  функция 1     |

Изначально все программы писались в процедурном ситле. Но когда программы
стали слишком большими стало сложно конфигурировать (настроивать) приложения,
сложно управлять сущностями, сложно делать декомпозицию.
Когда ПП стало недостаточно был придуман ООП.

# ООП

          |---> Методы

Объект |---> Свойства
|---> События

## Два основных понятия ООП

Класс - человек

Есть класс `Человек` и у него есть свойства `свойства` и есть `методы`

-------. -------------------------------------Имя------------ходить
------\|/ ------------------------------------Фамиля---------писать
-------| -------------------------------------Возраст--------рисовать
------/ \ ------------------------------------Вес------------говорить

---

-Рост

# Класс - это некоторое описание характеристик

# объект - это конкретный экземпляр у которого каждая характеристика имеет значение

Если создадим объект из класса Человек, то получим

объект

-------. --------------------------------Вася----------ходить
------\|/ -------------------------------Пупкин--------писать
-------| --------------------------------27------------рисовать
------/ \ -------------------------------70------------говорить
-----------------------------------------180

В контексте ООП описательные характеристики (вроде имя, фамилия) называют свойствами,
а действия которые может совершить тот или иной объект называются методами.

Классы могут содержать столько методов, сколько потребуется. Но хорошей практикой является
делать методы под конкретные задачи.

## Три основных концепции ООП - ИНКАПСУЛЯЦИЯ - НАСЛЕДОВАНИЕ - ПОЛИМОРФИЗМ

# Инкапсуляция и сокрытие

`Инкапсуляция` - суть в том, что класс является своего рода капсулой в которой есть какие-то
данные (свойства) и какие-то методы которые предназначены для работы с этими данными.
Другими словами мы не воздействуем на свойства напрямую как-либо изменяя их, а меняем
посредством методов. Таким образом, изменения свойств можно контролировать с помощью
условий или добавлять дополнительные вычисления.

-------. --------------------------------Вася----------`Изменить имя, получить имя` (получить значение поля имя обртившись к объекту)
------\|/ -------------------------------Пупкин--------изменить фамилию, получить фамилию
-------| --------------------------------27------------изменить дату рождения или возраст, получить дату рождения или возраст
------/ \ -------------------------------70------------изменить вес, получить вес
-----------------------------------------180

Рядом с инкапсуляцией идет `сокрытие` - Это скрытая часть это часть которая находится внутри человека на которую повлиять мы не можем.

-------. --------------------------------Вася---------- public Изменить имя, получить имя (получить значение поля имя обртившись к объекту)
------\|/ -------------------------------Пупкин--------public изменить фамилию, получить фамилию
-------| --------------------------------27------------public изменить дату рождения или возраст, получить дату рождения или возраст
------/ \ -------------------------------70------------public изменить вес, получить вес
-----------------------------------------180 ---------- `private качать кровь`
-------------------------------------------- ---------- `private обрабатывать информацию`

Для того чтобы делать какие-либо св-ва публичными или приватными в TS существуют модификаторы доступа public и private.
По умолчанию public, даже если не написать его. Но хорошей практикой явлется явно указать модификатор доступа.
Свойства помечены private можно вызывать внутри класса.

Например, у нас есть некоторый класс Database и у этого класса есть св-во url для подключения к БД и port.
Разработчик который пишет программу понимает, что если кто-то решит изменить url, то подключение к БД отвалится
и класс перестанет работать. Именно по этой причине он делает св-во url приватным и единственный способ установить
знач-е url и port - это конструктор класса.
То есть единожды при создании новго экзэмпляра класса задаем параметры и затем забываем про них.
Пример из encapsulation.ts класс Database.

# Наследование

класс Человек ---------> класс Работник ---------> класс Разработчик

---Имя---------------------Имя------------------------Имя
---Фамилия-----------------Фамилия--------------------Фамилия
---Возраст-----------------Возраст--------------------Возраст
---------------------------ИНН------------------------ИНН
---------------------------Снилс----------------------Снилс
---------------------------Серия----------------------Серия
---------------------------Номер----------------------Номер
------------------------------------------------------Язык программирования
------------------------------------------------------Уровень
------------------------------------------------------№ команды

Работник наследует свойства и методы класса Человек и добавлет нужные для работника свойства и методы,
а Разработчик наследует (расширяет) свойства и методы класса Работник и добавлет нужные для программиста
свойства и методы.

Хорошо испроектированная ООП система позволяет эффективно переиспользовать код, масштабировать его и поддерживать.

С помощью наследования можно создавать иерархию классов которые обладают своими уникальными св-ми и методами, при
этом каждый наследуемый класс перенимает св-ва и методы родительского класса.

# Полиморфизм

ПолиМорф - много форм. Если кратко, то это переопределение метода у родительского класса классом - потомком.
Это нужно чтобы работая с объектами одна и таже функция будет работала по разному.

Например, мы хотим чтобы созданные новые экземпляры объектов Человек, Работник и Разработчик могли поприветстовать.
Но у каждого будет свое приветсвие.

Человек Петя --------------------- Работник Вася ------------------- Разработчик Арсений

Привет, меня зовут Петя. ----------- Привет, я работник Вася.-------------Привет, я разработчик Арсений.

Создав метод "приветствие" в классе Человек, мы переопределим его в классе Работник и Разработчик.

## Взаимодействие между классами

Комозиция - это когда объект А управляет временем жизни объекта B.
Агрегация - это когда объект А получает ссылку на объект Б.

# Композиция

Это включение в объект одного класса объектов других классов в качестве его составных частей.

Объект класса Автомобиль содержит в себе другие объекты других классов.
Что характерно для композиции двигатель и колеса не могут существовать отдельно от автомобиля.
Они являются составной частью автомобиля и создаются как бы внутри него.

+класс Автомобиль (содержит в себе)
++двигатель (объект класса Двигатель)
++[ (массив из 4-х объектов)
+++ колесо (объект класса Колесо)
+++ колесо (объект класса Колесо)
+++ колесо (объект класса Колесо)
+++ колесо (объект класса Колесо)
]

# Агрегация

Агрегация может быть совместно с композицией.
Агрегация - это когда экземпляр двигателя и/или колеса в другом месте кода, и передается
в конструктор автомобиля через параметр конструктора.

# Абстрактный интерфейс

Это как оглавление в учебнике. Оно говорит что нужно сделать, но не говорит как это можно сделать.
Из interface нельзя сделать объект.

В нем описаны некоторые методы, какие параметры они принимают (какого-типа), и что возвращают эти методы.
Но при этом нет реализации.

# Абстрактные классы

Они похожи на абстрактные интерфейсы, в них так же можно объявить абстрактные методы. но при этом можно
создать и обычные методы с реализацией логики.

Класс который будет наследоваться от абстрактного, унаследует в себя все обычные методы и так же
должен будет реализовать все абстрактные методы т.е. записать в них какую-то логику.
